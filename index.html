<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Art Generator</title>
  <style>
    .shader {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        display: none;
    }
</style>
</head>
<body>
  <input type="text" id="userPrompt" placeholder="Enter your prompt">
  <button id="generateButton">Generate Art</button>
  <div class="shader" id="shader"></div>
  <div id="imageContainer"></div>
  <!-- Div separado para WebGL -->
  <div id="webglContainer">
    <canvas id="canvas" width="400" height="400"></canvas>
  </div>
  <script>
    const shaderCode = `
        vec3 palette(float t){
            vec3 a = vec3(-0.132, 0.258, 0.648);
            vec3 b = vec3(1.713, -1.047, -0.002);
            vec3 c = vec3(1.028, -3.142, 3.138);
            vec3 d = vec3(2.007, 1.447, 3.417);
            return a + b * cos(6.28318 * (c * t + d));
        }
        void mainImage(out vec4 fragColor, in vec2 fragCoord){
            vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;
            vec2 uv0 = uv;
            uv = fract(uv * 2.0) - 0.5;
            float d = length(uv);
            vec3 col = palette(length(uv0) + iTime);
            d = sin(d * 8. + iTime) / 8.;
            d = abs(d);
            d = 0.02 / d;
            col *= d;
            fragColor = vec4(col, 1.0);
        }
    `;
    document.addEventListener('DOMContentLoaded', function() {
      const canvas = document.getElementById('canvas');
      const gl = canvas.getContext('webgl');
      const vertexShaderCode = `
        attribute vec2 a_position;
        void main() {
            gl_Position = vec4(a_position, 0.0, 1.0);
        }
      `;
      const fragmentShaderCode = `
        precision mediump float;
        uniform vec2 iResolution;
        uniform float iTime;
        ${shaderCode}
        void main() {
            vec4 fragColor;
            mainImage(fragColor, gl_FragCoord.xy);
            gl_FragColor = fragColor;
        }
      `;
      function compileShader(shaderType, shaderCode) {
        const shader = gl.createShader(shaderType);
        gl.shaderSource(shader, shaderCode);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
          return null;
        }
        return shader;
      }
      function createProgram(vertexShader, fragmentShader) {
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          console.error('Program linking error:', gl.getProgramInfoLog(program));
          return null;
        }
        return program;
      }
      const vertexShader = compileShader(gl.VERTEX_SHADER, vertexShaderCode);
      const fragmentShader = compileShader(gl.FRAGMENT_SHADER, fragmentShaderCode);
      const program = createProgram(vertexShader, fragmentShader);
      gl.useProgram(program);
      const positionAttributeLocation = gl.getAttribLocation(program, 'a_position');
      const positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]), gl.STATIC_DRAW);
      gl.enableVertexAttribArray(positionAttributeLocation);
      gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);
      const resolutionUniformLocation = gl.getUniformLocation(program, 'iResolution');
      const timeUniformLocation = gl.getUniformLocation(program, 'iTime');
      function render() {
        gl.uniform2f(resolutionUniformLocation, canvas.width, canvas.height);
        gl.uniform1f(timeUniformLocation, performance.now() / 1000);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        requestAnimationFrame(render);
      }
      render();
    });
    async function generateAndDisplayArt() {
      console.log("Button clicked");
      // Obtener la entrada del usuario
      const userPrompt = document.getElementById('userPrompt').value || 'random complete';
      // Generar arte
      const postOptions = {
        method: 'POST',
        headers: {
          accept: 'application/json',
          'content-type': 'application/json',
          authorization: 'Bearer 45627a92-21bf-4099-8534-6335d475fc5f'
        },
        body: JSON.stringify({
          height: 512,
          modelId: '6bef9f1b-29cb-40c7-b9df-32b51c1f67d3',
          prompt: userPrompt,
          width: 512,
          num_images: 1
        })
      };
      let generationId;
      try {
        const response = await fetch('https://cloud.leonardo.ai/api/rest/v1/generations', postOptions);
        const data = await response.json();
        console.log("Generation Data:", data);
        generationId = data.sdGenerationJob.generationId;
      } catch (err) {
        console.error("Error in generation:", err);
        return;
      }
      // Consultar imágenes generadas
      const getOptions = {
        method: 'GET',
        headers: {
          accept: 'application/json',
          authorization: 'Bearer 45627a92-21bf-4099-8534-6335d475fc5f'
        }
      };
      let imageUrls = [];
      const maxAttempts = 10;
      let attempts = 0;
      while (imageUrls.length === 0 && attempts < maxAttempts) {
        try {
          const response = await fetch(`https://cloud.leonardo.ai/api/rest/v1/generations/${generationId}`, getOptions);
          const data = await response.json();
          console.log("Image Data:", data);
          imageUrls = data.generations_by_pk.generated_images.map(img => img.url);
          if (imageUrls.length === 0) {
            attempts++;
            await new Promise(resolve => setTimeout(resolve, 2000)); // Esperar 2 segundos
          } else {
            displayImages(imageUrls);
          }
        } catch (err) {
          console.error("Error al obtener imágenes:", err);
        }
      }
    }
    // Function to display the generated images
    function displayImages(urls) {
      const imageContainer = document.getElementById('imageContainer');
      // Clear the previous images
      imageContainer.innerHTML = '';
      // Create image elements for each URL and append them to the container
      urls.forEach(url => {
        const imageElement = document.createElement('img');
        imageElement.src = url;
        imageContainer.appendChild(imageElement);
      });
    }
    // Add an event listener to the "Generate Art" button
    const generateButton = document.getElementById('generateButton');
    generateButton.addEventListener('click', generateAndDisplayArt);
  </script>

  <script src="script.js"></script>
</body>
</html>
